@inproceedings{Menard:2018:SRR:3237009.3237026,
address = {New York, NY, USA},
author = {Menard, Kevin and Seaton, Chris and Daloze, Benoit},
booktitle = {Proceedings of the 15th International Conference on Managed Languages {\&} Runtimes},
doi = {10.1145/3237009.3237026},
isbn = {978-1-4503-6424-9},
keywords = { ruby, truffle,ropes},
pages = {10:1----10:7},
publisher = {ACM},
series = {ManLang '18},
title = {{Specializing Ropes for Ruby}},
url = {http://doi.acm.org/10.1145/3237009.3237026},
year = {2018}
}
@article{VanDeVanter2018,
author = {{Van De Vanter}, Michael and Seaton, Chris and Haupt, Michael and Humer, Christian and W{\"{u}}rthinger, Thomas},
doi = {https://doi.org/10.22152/programming-journal.org},
journal = {The Art, Science, and Engineering of Programming},
number = {3},
title = {{Fast, Flexible, Polyglot Instrumentation Support for Debuggers and other Tools}},
volume = {2},
year = {2018}
}
@phdthesis{Seaton2007,
author = {Seaton, Chris},
school = {University of Bristol},
title = {{A programming language where the syntax and semantics are mutable at runtime}},
year = {2007}
}
@phdthesis{Seaton2015,
author = {Seaton, Chris},
school = {University of Manchester},
title = {{Specialising Dynamic Techniques for Implementing the Ruby Programming Language}},
year = {2015}
}
@article{Grimmer2018,
author = {Grimmer, Matthias and Schatz, Roland and Seaton, Chris and W{\"{u}}rthinger, Thomas and Luj{\'{a}}n, Mikel},
doi = {10.1145/3201898},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
month = {may},
number = {2},
pages = {1--43},
title = {{Cross-Language Interoperability in a Multi-Language Runtime}},
url = {http://dl.acm.org/citation.cfm?doid=3229520.3201898},
volume = {40},
year = {2018}
}
@inproceedings{Seaton2016,
author = {Seaton, Chris},
booktitle = {Proceedings of the 1st Workshop on Meta-Programming Techniques and Reflection},
title = {{AST Specialisation and Partial Evaluation for Easy High-Performance Metaprogramming}},
year = {2016}
}
@inproceedings{Seaton2012,
author = {Seaton, Chris and Goodman, Daniel and Luj{\'{a}}n, Mikel and Watson, Ian},
booktitle = {Proceedings of the 7th Workshop on Programmability Issues for Heterogeneous Multicores},
title = {{Applying dataflow and transactions to Lee routing}},
year = {2012}
}
@inproceedings{Wurthinger2017,
abstract = {Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system. This violates the principle to not repeat yourself. In contrast, we define languages solely by writing an interpreter. The interpreter performs specializations, e.g., augments the interpreted program with type information and profiling information. Compiled code is derived automatically using partial evaluation while incorporating these specializations. This makes partial evaluation practical in the context of dynamic languages: It reduces the size of the compiled code while still compiling all parts of an operation that are relevant for a particular program. When a speculation fails, execution transfers back to the interpreter, the program re-specializes in the interpreter, and later partial evaluation again transforms the new state of the interpreter to compiled code. We evaluate our approach by comparing our implementations of JavaScript, Ruby, and R with best-inclass specialized production implementations. Our generalpurpose compilation system is competitive with production systems even when they have been heavily optimized for the one language they support. For our set of benchmarks, our speedup relative to the V8 JavaScript VM is 0.83x, relative to JRuby is 3.8x, and relative to GNU R is 5x. Copyright is held by the owner/author(s).},
author = {W{\"{u}}rthinger, T. and Wimmer, C. and Humer, C. and W{\"{o}}{\ss}, A. and Stadler, L. and Seaton, C. and Duboscq, G. and Simon, D. and Grimmery, M.},
booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
doi = {10.1145/3062341.3062381},
isbn = {9781450349888},
keywords = {Dynamic languages,Language implementation,Optimization,Partial evaluation,Virtual machine},
title = {{Practical partial evaluation for high-performance dynamic language runtimes}},
volume = {Part F1284},
year = {2017}
}
@article{Barnes2015,
abstract = {{\textcopyright} 2015, BMJ Publishing Group. All rights reserved. Introduction: 'Mersey Burns App' is a smartphone/ tablet application that aids in the assessment of total burn surface area (TBSA) and calculation of fluid resuscitation protocols in burns. This paper presents two studies assessing the speed and accuracy of calculations using Mersey Burns (App) in comparison with a Lund and Browder chart (paper) when a burn is assessed by medical students and clinicians. Methods: The first study compared the speed and accuracy of TBSA and resuscitation calculation for a photograph of a burn with App and paper using burns and plastics and emergency medicine trainees and consultants. Developing on some of the feedback and results of that study, a second study was then carried out using burns-naive medical students assessing a fully simulated burn with both modalities. Preference and ease of use of each modality were assessed anonymously. Results: The clinician study showed a lower variance in TBSA and fluid calculations using the App (p{\textless}0.05). The student study showed no difference in mean TBSA estimations (p=0.7). Mean time to completion of calculations was faster and calculations were more likely to be correct with the App (p{\textless}0.001). Students favoured the App in the following categories: preference in emergency setting, confidence in output, accuracy, speed, ease of calculation, overall use and shading (p{\textless}0.0001). Conclusions: Mersey Burns App can facilitate quicker and more accurate calculations than Lund and Browder charts. Students also preferred the App. This suggests a useful role for the App in the care of patients with burns by inexperienced staff.},
author = {Barnes, J. and Duffy, A. and Hamnett, N. and McPhail, J. and Seaton, C. and Shokrollahi, K. and James, M.I. and McArthur, P. and Jones, R.P.},
doi = {10.1136/emermed-2013-203416},
issn = {14720213},
journal = {Emergency Medicine Journal},
number = {8},
title = {{The Mersey Burns App: Evolving a model of validation}},
volume = {32},
year = {2015}
}
@article{Sofos2012,
author = {Sofos, S.S. and Pritchard-Jones, R. and Seaton, C. and Dingley, J. and McArthur, P. and Shokrollahi, K.},
doi = {10.1097/SAP.0b013e31826b13a9},
issn = {01487043},
journal = {Annals of Plastic Surgery},
number = {3},
title = {{Medical innovation - A starting point for plastic surgeons}},
volume = {69},
year = {2012}
}
@article{MacKey2012,
abstract = {Background: Breast-conserving surgery is often preferred to treat early-stage breast cancer. This method aims to minimize repeat excision and local recurrence rates. The ABLATE Registry expands this to multiple centers with a total accrual goal of 250. This video illustrates an intraoperative radiofrequency ablation (RFA) technique. Methods: Sixteen women with a mean age of 65 years underwent RFA after lumpectomy. The RFA probe was deployed 1 cm circumferentially in the cavity and maintained at 100°C for 15 min. The ablation zone was monitored with color-flow ultrasound. Patients returned 2 weeks later to complete the Subjective Cosmetic Scale and the European Organisation for Research and Treatment of Cancer Body Image Scale. Results: At a mean follow-up of 3.9 months, there were no local recurrences. Two-week cosmesis scores were excellent (n = 9) or good (n = 5). Conclusions: Our initial experience is encouraging. Continued national accrual will permit evaluation of reduction in repeat excision and local recurrence rate, as well as potentially reduce requirements for adjuvant radiation. {\textcopyright} 2012 Society of Surgical Oncology.},
author = {MacKey, A. and Feldman, S. and Vaz, A. and Durrant, L. and Seaton, C. and Klimberg, V.S.},
doi = {10.1245/s10434-012-2293-7},
issn = {10689265},
journal = {Annals of Surgical Oncology},
number = {8},
title = {{Radiofrequency ablation after breast lumpectomy added to extend intraoperative margins in the treatment of breast cancer (ABLATE): A single-institution experience}},
volume = {19},
year = {2012}
}
@inproceedings{Woß2014,
abstract = {Copyright {\textcopyright} 2014 ACM. Truffle is a Java-based framework for developing high-performance language runtimes. Language implementers aiming at developing new runtimes have to design all the runtime mechanisms for managing dynamically typed objects from scratch. This not only leads to potential code duplication, but also impacts the actual time needed to develop a fully-fledged runtime. In this paper we address this issue by introducing a common object storage model (OSM) for Truffle that can be used by language implementers to develop new runtimes. The OSM is generic, language-agnostic, and portable, as it can be used to implement a great variety of dynamic languages. It is extensible, featuring built-in support for custom extension mechanisms. It is also highperformance, as it is designed to benefit from the optimizing compiler in the Truffle framework. Our initial evaluation indicates that the Truffle OSM can be used to implement high-performance language runtimes, with no performance overhead when compared to language-specific solutions.},
author = {W{\"{o}}{\ss}, A. and Wirth, C. and Bonetta, D. and Seaton, C. and Humer, C. and M{\"{o}}ssenb{\"{o}}ck, H.},
booktitle = {ACM International Conference Proceeding Series},
doi = {10.1145/2647508.2647517},
isbn = {9781450330640},
keywords = {Dynamic languages,Java,JavaScript,Language implementation,Optimization,Ruby,Truffle,virtual machine},
title = {{An object storage model for the Truffle language implementation framework}},
volume = {13-Decembe},
year = {2014}
}
@inproceedings{Goodman2013,
abstract = {In this paper we present DFScala, a library for constructing and executing dataflow graphs in the Scala language. Through the use of Scala this library allows the programmer to construct coarse grained dataflow graphs that take advantage of functional semantics for the dataflow graph and both functional and imperative semantics within the dataflow nodes. This combination allows for very clean code which exhibits the properties of dataflow programs, but we believe is more accessible to imperative programmers. We first describe DFScala in detail, before using a number of benchmarks to evaluate both its scalability and its absolute performance relative to existing codes. DFScala has been constructed as part of the Teraflux project and is being used extensively as a basis for further research into dataflow programming. {\textcopyright} 2013 IEEE.},
author = {Goodman, D. and Khan, S. and Seaton, C. and Guskov, Y. and Khan, B. and Luj{\'{a}}n, M. and Watson, I.},
booktitle = {Proceedings - 2012 2nd Workshop on Data-Flow Execution Models for Extreme Scale Computing, DFM 2012},
doi = {10.1109/DFM.2012.12},
isbn = {9780768549545},
keywords = {Coarse grained,Dataflow,Parallel programming model,Scala},
title = {{DFScala: High level dataflow support for scala}},
year = {2013}
}
@inproceedings{Grimmer2015,
abstract = {Copyright {\textcopyright} 2015 ACM. Programmers combine different programming languages because it allows them to use the most suitable language for a given problem, to gradually migrate existing projects from one language to another, or to reuse existing source code. However, existing cross-language mechanisms suffer from complex interfaces, insufficient flexibility, or poor performance. We present the TruffleVM, a multi-language runtime that allows composing different language implementations in a seamless way. It reduces the amount of required boilerplate code to a minimum by allowing programmers to access foreign functions or objects by using the notation of the host language. We compose language implementations that translate source code to an intermediate representation (IR), which is executed on top of a shared runtime system. Language implementations use language-independent messages that the runtime resolves at their first execution by transforming them to efficient foreign-language-specific operations. The TruffleVM avoids conversion or marshaling of foreign objects at the language boundary and allows the dynamic compiler to perform its optimizations across language boundaries, which guarantees high performance. This paper presents an implementation of our ideas based on the Truffle system and its guest language implementations JavaScript, Ruby, and C.},
author = {Grimmer, M. and Schatz, R. and Seaton, C. and W{\"{u}}rthinger, T. and Mossenbock, H.},
booktitle = {DLS 2015 - Proceedings of the 11th Symposium on Dynamic Languages},
doi = {10.1145/2816707.2816714},
isbn = {9781450336901},
keywords = {Cross-language,Language implementation,Language interoperability,Optimization,Virtual machine},
title = {{High-performance cross-language interoperability in a multi-language runtime}},
year = {2015}
}
@article{Marr2015,
abstract = {{\textcopyright} 2015 ACM. Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as re-flective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.},
author = {Marr, S. and Seaton, C. and Ducasse, S.},
doi = {10.1145/2737924.2737963},
issn = {15232867},
journal = {ACM SIGPLAN Notices},
keywords = {Justin-Time Compilation,Meta-tracing,Metaobject Protocols,Metaprogramming,Partial Evaluation,Proxies,Reflection,Virtual Machines},
number = {6},
title = {{Zero-overhead metaprogramming: Reflection and metaobject protocols fast and without compromises}},
volume = {50},
year = {2015}
}
@inproceedings{Marr2015a,
abstract = {Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications. Copyright is held by the owner/author(s). Publication rights licensed to ACM.},
author = {Marr, S. and Seaton, C. and Ducasse, S.},
booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
doi = {10.1145/2737924.2737963},
isbn = {9781450334686},
keywords = {Justin-time compilation,Meta-tracing,Metaobject protocols,Metaprogramming,Partial evaluation,Proxies,Reflection,Virtual machines},
title = {{Zero-overhead metaprogramming reflection and metaobject protocols fast and without compromises}},
volume = {2015-June},
year = {2015}
}
@inproceedings{Daloze2015,
abstract = {Safepoints are a virtual machine mechanism that allows one thread to suspend other threads in a known state so that runtime actions can be performed without interruption and with data structures in a consistent state. Many virtual machines use safepoints as a mechanism to provide services such as stop-the-world garbage collection, debugging, and modification to running code such as installing or replacing classes. Languages implemented on these virtual machines may have access to these services, but not directly to the safepoint mechanism itself. We show that safepoints have many useful applications for the implementation of guest languages running on a virtual machine. We describe an API for using safepoints in languages that were implemented under the Truffle language implementation framework on the Java Virtual Machine and show several applications of the API to implement useful guest-language functionality. We present an efficient implementation of this API, when running in combination with the Graal dynamic compiler.We also demonstrate that our safepoints cause zero overhead with respect to peak performance and statistically insignificant overhead with respect to compilation time. We compare this to other techniques that could be used to implement the same functionality and demonstrate the large overhead that they incur.},
author = {Daloze, B. and Seaton, C. and Bonetta, D. and M{\"{o}}ssenb{\"{o}}ck, H.},
booktitle = {Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems, ICOOOLPS 2015},
doi = {10.1145/2843915.2843921},
isbn = {9781450336574},
keywords = {Graal,Java,Javascript,Ruby,Safepoints,Truffle,Virtual machine},
title = {{Techniques and applications for guest-language safepoints}},
year = {2015}
}
@inproceedings{Seaton2014,
abstract = {Debugging support for highly optimized execution environments is notoriously difficult to implement. The Truffle/Graal platform for implementing dynamic languages offers an opportunity to resolve the apparent trade-off between debugging and high performance. Truffle/Graal-implemented languages are expressed as abstract syntax tree (AST) interpreters. They enjoy competitive performance through platform support for type specialization, partial evaluation, and dynamic optimization/deoptimization. A prototype debugger for Ruby, implemented on this platform, demonstrates that basic debugging services can be implemented with modest effort and without significant impact on program performance. Prototyped functionality includes breakpoints, both simple and conditional, at lines and at local variable assignments. The debugger interacts with running programs by inserting additional nodes at strategic AST locations; these are semantically transparent by default, but when activated can observe and interrupt execution. By becoming in effect part of the executing program, these "wrapper" nodes are subject to full runtime optimization, and they incur zero runtime overhead when debugging actions are not activated. Conditions carry no overhead beyond evaluation of the expression, which is optimized in the same way as user code, greatly improving the prospects for capturing rarely manifested bugs. When a breakpoint interrupts program execution, the platform automatically restores the full execution state of the program (expressed as Java data structures), as if running in the unoptimized AST interpreter. This then allows full introspection of the execution data structures such as the AST and method activation frames when in the interactive debugger console. Our initial evaluation indicates that such support could be permanently enabled in production environments. {\textcopyright} 2014 ACM.},
author = {Seaton, C. and {Van De Vanter}, M.L. and Haupt, M.},
booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
doi = {10.1145/2617548.2617550},
isbn = {9781450329163},
keywords = {Truffle,deoptimization,virtual machines},
title = {{Debugging at full speed}},
year = {2014}
}
@inproceedings{Grimmer2015a,
abstract = {Copyright 2015 ACM. Many dynamic languages such as Ruby, Python and Perl offer some kind of functionality for writing parts of applications in a lower-level language such as C. These C extension modules are usually written against the API of an interpreter, which provides access to the higher-level language's internal data structures. Alternative implementations of the high-level languages often do not support such C extensions because implementing the same API as in the original implementations is complicated and limits performance. In this paper we describe a novel approach for modular composition of languages that allows dynamic languages to support C extensions through interpretation. We propose a flexible and reusable cross-language mechanism that allows composing multiple language interpreters, which run on the same VM and share the same form of intermediate representation - in this case abstract syntax trees. This mechanism allows us to efficiently exchange runtime data across different interpreters and also enables the dynamic compiler of the host VM to inline and optimize programs across multiple language boundaries. We evaluate our approach by composing a Ruby interpreter with a C interpreter. We run existing Ruby C extensions and show how our system executes combined Ruby and C modules on average over 3x faster than the conventional implementation of Ruby with native C extensions, and on average over 20x faster than an existing alternate Ruby implementation on the JVM (JRuby) calling compiled C extensions through a bridge interface. We demonstrate that cross-language inlining, which is not possible with native code, is performance-critical by showing how speedup is reduced by around 50{\%} when it is disabled.},
author = {Grimmer, M. and Seaton, C. and W{\"{u}}rthinger, T. and M{\"{o}}ssenb{\"{o}}ck, H.},
booktitle = {ACM International Conference Proceeding Series},
doi = {10.1145/2724525.2728790},
isbn = {9781450332491},
keywords = {C,Cross-language,Language interoperability,Native Extension,Optimization,Ruby,Virtual machine},
title = {{Dynamically composing languages in a modular way: Supporting C extensions for dynamic languages}},
volume = {16-19-Marc},
year = {2015}
}
@inproceedings{Grimmer2015b,
abstract = {{\textcopyright} 2015 ACM. In low-level languages such as C, spatial and temporal safety errors (e.g. buffer overflows or dangling pointer dereferences) are hard to find and can cause security vulnerabilities. Modern high-level languages such as Java avoid these problems by running programs on a virtual machine that provides automated memory management. In this paper we show how we can safely execute C code on top of a modern runtime (e.g., a Java Virtual Machine) by allocating all data on the managed heap. We reuse the memory management of the runtime, hence, we can ensure spatial and temporal safety with little effort. Nevertheless, we retain all characteristics that are typical for unsafe languages (such as pointer arithmetic, pointers into objects, or arbitrary type casts).We discuss how our approach complies with the C99 standard. Compared to an optimized unsafe execution of a C program (compiled with the GNU C compiler and all optimizations enabled) our approach has overhead of 15{\%} on average (peak-performance).},
author = {Grimmer, M. and Schatz, R. and Seaton, C. and W{\"{u}}rthinger, T.},
booktitle = {Proceedings of the 10th ACM Workshop on Programming Languages and Analysis for Security, PLAS 2015},
doi = {10.1145/2786558.2786565},
isbn = {9781450336611},
keywords = {C,Dynamic Compilation,Graal,ManagedC,Memory Safety,Optimization,Truffle,Virtual Machine},
title = {{Memory-safe execution of C on a Java VM}},
year = {2015}
}
