<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>A Truffle/Graal High Performance Backend for JRuby</title>

<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<meta name="viewport" content="initial-scale=1.0">

<link rel="stylesheet" href="http://cdn.jsdelivr.net/normalize/2.1.0/normalize.css">

<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300">
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.0.2/css/font-awesome.css">

<link rel="stylesheet" href="../../common.css">
<link rel="stylesheet" href="../../article.css">

</head>

<body>

<article>

<header>
<h1 class="article-smaller">A Truffle/Graal High Performance Backend for JRuby</h1>
<h2><a href="/">Chris Seaton</a>, 6 January 2014</h2>
<img alt="Ruby Logo (Copyright (c) 2006, Yukihiro Matsumoto. Licensed
under the terms of Creative Commons Attribution-ShareAlike 2.5.)" src="../ruby.png" width="96" height="96">
<img alt="JRuby Logo (Copyright (c) 2011, Tony Price. Licensed
under the terms of Creative Commons Attribution-NoDerivs 3.0 Unported (CC BY-ND 3.0))." src="../jruby.png" width="96" height="96">
</header>

<p>For the past year <a href="https://labs.oracle.com">Oracle Labs</a> have been working on an implementation of Ruby built upon two new JVM technologies - <a href="http://openjdk.java.net/projects/graal/">the Truffle AST interpreter framework and the Graal JVM compiler</a>. We believe that the new approach will lead to a faster and simpler Ruby implementation.</p>
<p>We’ve been talking to Charles Nutter and Thomas Enebo for several months and have given them early access to our code. We’ve also been talking to other Ruby implementors such as Alex Gaynor of Topaz, and presenting our results to the JVM language community at the <a href="http://medianetwork.oracle.com/video/player/2623645003001">JVM language summit</a>. Today we are open sourcing our implementation and, with the consent of Charles and Thomas, pushing a patch that begins the integration as an optional backend in JRuby.</p>
<p>This blog post describes some of the background to this project. The <a href="http://hg.openjdk.java.net/graal/graal">original code</a> is available in the Graal Mercurial repository and the <a href="https://github.com/jruby/jruby/tree/truffle">patch to JRuby</a> is available in a new <code>truffle</code> branch in the JRuby Git repository. There is <a href="https://github.com/jruby/jruby/wiki/Truffle">documentation of how to use the code and an FAQ</a> in the JRuby wiki, as well as pointers to more in-depth technical information such as peer-reviewed research publications.</p>
<h2 id="what-does-this-new-implementation-do-differently">What does this new implementation do differently?</h2>
<p>The new backend is an AST interpreter. We call it the Truffle backend because it’s written using the <a href="http://openjdk.java.net/projects/graal/">Truffle framework for writing AST interpreters</a> from Oracle Labs.</p>
<p>Truffle is different to other AST interpreters in that it creates ASTs that specialize as they execute. The AST interpretation methods that are currently in JRuby are megamorphic, which means that they must handle all possible types and other dynamic conditions such as branches taken. In Truffle, AST nodes ideally handle a minimal set of conditions, allowing them to be simpler and more statically typed, which can lead to more efficient code. In the less common case that the node's conditions aren’t met the node is replaced with another node that can handle them.</p>
<p>AST interpreters are generally thought of as being slow. This is because every operation becomes something such as a virtual method call. MRI 1.8 used a simple AST interpreter, and JRuby still uses an AST interpreter by default for the first run of methods. To improve performance many language implementations convert the AST to bytecode. Python, Ruby 1.9 and above (via YARV) and PHP all do this. Normally the bytecode is still interpreted, but it’s often faster as the data structure is more compactly represented in memory. In the case of many JVM languages like JRuby and other Ruby implementations such as Topaz and Rubinius, this bytecode is eventually compiled into machine code by the JIT compiler.</p>
<p>Again, Truffle takes a different approach here. When running on JVM with the Graal JIT compiler, Truffle will take all of the methods involved in interpreting your AST and will combine them into a single method. The powerful optimisations that the JVM usually applies to single methods are applied across the combined AST methods and a single machine code function per Ruby method is emitted by Graal.</p>
<p>For more information about what Truffle and Graal do see the <a href="https://github.com/jruby/jruby/wiki/Truffle">JRuby wiki page</a>, the a recent <a href="http://www.slideshare.net/ThomasWuerthinger/graal-truffle-ethdec2013">project summary slide deck</a>.</p>
<h2 id="is-this-going-to-change-with-how-you-use-jruby-today">Is this going to change with how you use JRuby today?</h2>
<p>The Truffle backend, Truffle itself, and Graal are research projects and are certainly not ready for general use today. It is very unlikely that your application or gem will run right now, but if you are interested in the JRuby internals, or the JVM or compiler technology in general we’d encourage you to take a look at what we’re doing. The <a href="https://github.com/jruby/jruby/wiki/Truffle">JRuby wiki page</a> will give you a starting point.</p>
<p>For the foreseeable future this work is going to live on a separate <a href="https://github.com/jruby/jruby/tree/master/core/src/main/java/org/jruby/truffle"><code>truffle</code> branch</a> in the main JRuby Git repository. It is possible that this branch will be considered for merging into the master branch before the next major release, JRuby 9000, but this a decision for the wider JRuby community and its leadership.</p>
<p>We believe that in the further future the Truffle backend could be good enough to become the default backend for JRuby, but again this is a decision for the JRuby community.</p>
<h2 id="what-are-we-going-to-do-next">What are we going to do next?</h2>
<p>We are going to continue to integrate Truffle into JRuby at the same time as continuing to implement more of the Ruby language. We already have very encouraging results with our initial implementation and with the excellent work already done by the JRuby community we think we can fill in the gaps to be a complete implementation.</p>

<hr>

<ul>
  <li><a href="../cext/">Very High Performance C Extensions For JRuby+Truffle</a></li>
  <li><a href="../small-data-structures/">Optimising Small Data Structures in JRuby+Truffle</a></li>
  <li><a href="../pushing-pixels/">Pushing Pixels with JRuby+Truffle</a></li>
  <li><a href="../set_trace_func/">Tracing With Zero Overhead in JRuby+Truffle</a></li>
  <li><a href="../how-method-dispatch-works-in-jruby-truffle/">How Method Dispatch Works in JRuby+Truffle</a></li>
  <li><a href="../..">Chris Seaton's website</a></li>
</ul>

<hr>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chrisseaton'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr>

<footer>
<p>Copyright © Chris Seaton 2014</p>
<p>Opinions are my own.</p>
</footer>

</article>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37318201-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
